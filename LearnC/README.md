`gcc -o hello hello.c`


# 浮点数在计算中机中的存储


### 一个示例

> 下面代码中 `printf("*pFloat的值为: %f\n", *pFloat);` 的值为什么为`0.000000`

```c
#include <stdio.h>

int main(void)
{
    int num = 9;	// num是整形变量，设为9
    float* pFloat = &num;	// pFloat 表示num的内存地址，但是设置为浮点数
    printf("num 的值为: %d\n", num);
    printf("*pFloat的值为: %f\n", *pFloat);	// 显示num的浮点值
    *pFloat = 9.0;	// 将num的值改为浮点数
    printf("num的值为: %d\n", num);	// 显示num的整型值
    printf("pFloat的值为: %f\n", *pFloat);	// 显示num的浮点值
    return 0;
}

/* 输出结果如下：
num 的值为: 9
*pFloat的值为: 0.000000
num的值为: 1091567616
pFloat的值为: 9.000000
*/
```

#### 原因分析，单精度浮点数存储占用4个字节，按照 IEEE 754规范可以知道

> 上面这条命令，声明了一个整数变量，类型为int，值为9（二进制写法为1001）。普通的32位计算机，用4个字节表示int变量，所以9就被保存为00000000 00000000 00000000 00001001，写成16进制就是0x00000009。那么，我们的问题就简化成：为什么0x00000009还原成浮点数，就成了0.000000

- 任意一个二进制浮点数V可以表示成为 V = (-1)^S * M * 2^E
	- (-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数
	- M表示有效数字，大于等于1，小于2
		- M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分
		- IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分
			- 比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去
			- 这样做的目的，是节省1位有效数字
			- 以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字
	- 2^E表示指数位
		- E为一个无符号整数（unsigned int）。这意味着，如果E为8位，它的取值范围为0~255
		- 如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的
		- 所以IEEE 754规定，E的真实值必须再减去一个中间数，对于8位的E，这个中间数是127,对于11位的E，这个中间数是1023
	- 指数E还可以再分成三种情况
		- E不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1
		- E全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字
		- E全为1。这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）

> 比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001

- - 存储最高位表示符号位，后面9位位指数位，最后23位尾数位置

> 浮点数9.0 表示为2进制格式为  00000000 00000000 00000000 00001001 最高位位0 

- 最高位位0 (-1)^S = 1
- 8位指数位全为 0 则 E=000 0000 0；这时 E=1-127 = -126
- 剩余的小说位位: 0.0000000 00000000 00001001 移动小数点表示为 1.xxxx 位则M=1.001 * 2^(-20) 

> 综上  V = (-1)^S * M * 2^E  = (-1)^0 * 1.001 * 2^(-20) * 2^-126 = 1.001 * 2^-146 显然，V是一个很小的接近于0的正数，所以用十进制小数表示就是0.000000



#### 参考

- https://www.h-schmidt.net/FloatConverter/IEEE754.html
